"""
Visualization utilities for vulnerability analysis.

This module provides functions for creating visualizations related to
power grid vulnerability analysis.
"""

import os
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
import seaborn as sns
from typing import Dict, List, Union, Optional, Any, Tuple
import logging

# Configure logging
logger = logging.getLogger(__name__)

def setup_plot_style():
    """Set up consistent plotting style."""
    # Use a style that's compatible with newer matplotlib versions
    try:
        # First try seaborn style directly
        sns.set_style('whitegrid')
    except Exception as e:
        # If that fails, try matplotlib styles
        try:
            plt.style.use('ggplot')  # A common style available in matplotlib
        except Exception as e:
            logger.warning(f"Could not set plot style: {e}")
            # Just use default style if both options fail
    
    plt.rcParams['figure.figsize'] = (12, 8)
    plt.rcParams['font.size'] = 12
    plt.rcParams['axes.labelsize'] = 14
    plt.rcParams['axes.titlesize'] = 16
    plt.rcParams['xtick.labelsize'] = 12
    plt.rcParams['ytick.labelsize'] = 12
    plt.rcParams['legend.fontsize'] = 12

def plot_component_vulnerability_scores(
    vulnerability_scores: pd.DataFrame,
    top_n: int = 10,  # Reduced from 20 to 10 to prevent oversized plots
    save_path: Optional[str] = None,
    figsize: Tuple[int, int] = (10, 6)  # Control figure size explicitly
) -> plt.Figure:
    """
    Plot component vulnerability scores.
    
    Args:
        vulnerability_scores: DataFrame with vulnerability scores
        top_n: Number of top vulnerable components to show
        save_path: Path to save the figure
        
    Returns:
        plt.Figure: The created figure
    """
    # Override default figure size for this plot
    plt.rcParams['figure.figsize'] = figsize
    setup_plot_style()
    
    # Sort by vulnerability score and limit to top_n components (max 10)
    top_n = min(top_n, 10)  # Safety limit on number of components
    sorted_df = vulnerability_scores.sort_values('vulnerability_score', ascending=False).head(top_n)
    
    # Select top N components
    plot_df = sorted_df.copy()
    
    # Create plot
    fig, ax = plt.subplots(figsize=(14, 8))
    
    # Plot horizontal bar chart
    colors = plt.cm.RdYlGn_r(np.linspace(0, 1, len(plot_df)))
    bars = ax.barh(
        plot_df['component_id'],
        plot_df['vulnerability_score'],
        color=colors
    )
    
    # Add component type as text
    if 'component_type' in plot_df.columns:
        for i, (_, row) in enumerate(plot_df.iterrows()):
            ax.text(
                row['vulnerability_score'] + 0.01,
                i,
                f"({row['component_type']})",
                va='center'
            )
    
    # Customize plot
    ax.set_xlabel('Vulnerability Score')
    ax.set_ylabel('Component ID')
    ax.set_title(f'Top {top_n} Most Vulnerable Grid Components')
    
    # Set x-axis limits
    ax.set_xlim(0, min(1.0, plot_df['vulnerability_score'].max() * 1.2))
    
    # Add color bar
    sm = plt.cm.ScalarMappable(
        cmap=plt.cm.RdYlGn_r,
        norm=plt.Normalize(0, 1)
    )
    sm.set_array([])
    cbar = fig.colorbar(sm, ax=ax)
    cbar.set_label('Vulnerability Level')
    
    plt.tight_layout()
    
    # Save figure if path provided
    if save_path:
        try:
            # Use a lower DPI to reduce overall image size
            plt.savefig(save_path, dpi=150, bbox_inches='tight')
            logger.info(f"Saved component vulnerability plot to {save_path}")
        except Exception as e:
            logger.warning(f"Error saving plot: {e}")
            # Try with even smaller settings if the first attempt failed
            try:
                plt.close(fig)  # Close the current figure
                plt.figure(figsize=(8, 5))  # Create a smaller figure
                plt.bar(plot_df['component_id'], plot_df['vulnerability_score'])
                plt.title("Component Vulnerability Scores (Simplified)")
                plt.xticks(rotation=45, ha='right')
                plt.tight_layout()
                plt.savefig(save_path, dpi=100)
                logger.info(f"Saved simplified vulnerability plot to {save_path}")
            except Exception as e2:
                logger.error(f"Failed to save even simplified plot: {e2}")
    
    return fig

def plot_vulnerability_distribution(
    vulnerability_scores: pd.DataFrame,
    group_by: Optional[str] = 'component_type',
    save_path: Optional[str] = None
) -> plt.Figure:
    """
    Plot distribution of vulnerability scores.
    
    Args:
        vulnerability_scores: DataFrame with vulnerability scores
        group_by: Column to group by (None for no grouping)
        save_path: Path to save the figure
        
    Returns:
        plt.Figure: The created figure
    """
    setup_plot_style()
    
    if group_by and group_by in vulnerability_scores.columns:
        # Create plot with grouping
        fig, ax = plt.subplots(figsize=(14, 8))
        
        # Get unique groups
        groups = vulnerability_scores[group_by].unique()
        
        # Create a histogram for each group
        for group in groups:
            group_data = vulnerability_scores[
                vulnerability_scores[group_by] == group
            ]['vulnerability_score']
            
            sns.kdeplot(
                group_data,
                label=f"{group} (n={len(group_data)})",
                ax=ax
            )
        
        # Add vertical lines for group medians
        for group in groups:
            group_data = vulnerability_scores[
                vulnerability_scores[group_by] == group
            ]['vulnerability_score']
            
            median = group_data.median()
            ax.axvline(
                median,
                linestyle='--',
                color='gray',
                alpha=0.5
            )
            ax.text(
                median,
                ax.get_ylim()[1] * 0.9,
                f"{median:.2f}",
                ha='center',
                va='top',
                bbox=dict(facecolor='white', alpha=0.5)
            )
        
        # Customize plot
        ax.set_xlabel('Vulnerability Score')
        ax.set_ylabel('Density')
        ax.set_title(f'Distribution of Vulnerability Scores by {group_by}')
        ax.legend(title=group_by)
    
    else:
        # Create plot without grouping
        fig, ax = plt.subplots(figsize=(14, 8))
        
        # Create histogram
        sns.histplot(
            vulnerability_scores['vulnerability_score'],
            bins=20,
            kde=True,
            ax=ax
        )
        
        # Add median line
        median = vulnerability_scores['vulnerability_score'].median()
        ax.axvline(
            median,
            color='red',
            linestyle='--',
            label=f'Median: {median:.2f}'
        )
        
        # Customize plot
        ax.set_xlabel('Vulnerability Score')
        ax.set_ylabel('Count')
        ax.set_title('Distribution of Vulnerability Scores')
        ax.legend()
    
    plt.tight_layout()
    
    # Save figure if path provided
    if save_path:
        plt.savefig(save_path, dpi=300, bbox_inches='tight')
        logger.info(f"Saved vulnerability distribution plot to {save_path}")
    
    return fig

def plot_environmental_threat_heatmap(
    threat_profiles: pd.DataFrame,
    location_col: str = 'location',
    threat_col: str = 'threat_level',
    title: str = 'Environmental Threat Heatmap',
    save_path: Optional[str] = None
) -> plt.Figure:
    """
    Plot heatmap of environmental threats by location.
    
    Args:
        threat_profiles: DataFrame with threat profiles
        location_col: Column with location information
        threat_col: Column with threat level
        title: Plot title
        save_path: Path to save the figure
        
    Returns:
        plt.Figure: The created figure
    """
    setup_plot_style()
    
    # Pivot data into a matrix
    if location_col in threat_profiles.columns:
        # Try to extract location coordinates
        try:
            # Check if location is in the format "(lat, lon)"
            threat_profiles['lat'] = threat_profiles[location_col].str.extract(r'\(([^,]+),')[0].astype(float)
            threat_profiles['lon'] = threat_profiles[location_col].str.extract(r',\s*([^)]+)\)')[0].astype(float)
            
            use_coordinates = True
        except:
            # If extraction fails, use locations as-is
            use_coordinates = False
            pivot_df = threat_profiles.pivot_table(
                index=location_col,
                values=threat_col,
                aggfunc='mean'
            ).reset_index()
    else:
        # If location column doesn't exist, use index as location
        use_coordinates = False
        pivot_df = threat_profiles.reset_index()
        pivot_df.columns = [location_col, threat_col]
    
    # Create plot
    if use_coordinates:
        # Create scatter plot with coordinates
        fig, ax = plt.subplots(figsize=(12, 10))
        
        scatter = ax.scatter(
            threat_profiles['lon'],
            threat_profiles['lat'],
            c=threat_profiles[threat_col],
            cmap='RdYlGn_r',
            s=100,
            alpha=0.7,
            edgecolors='k'
        )
        
        # Add colorbar
        cbar = plt.colorbar(scatter, ax=ax)
        cbar.set_label('Threat Level')
        
        # Customize plot
        ax.set_xlabel('Longitude')
        ax.set_ylabel('Latitude')
        ax.set_title(title)
        
        # Try to set aspect ratio to equal for geographic data
        ax.set_aspect('equal')
    
    else:
        # Create heatmap with non-coordinate locations
        fig, ax = plt.subplots(figsize=(12, len(pivot_df) * 0.4 + 2))
        
        # Sort by threat level
        pivot_df = pivot_df.sort_values(threat_col, ascending=False)
        
        # Create horizontal bar chart
        bars = ax.barh(
            pivot_df[location_col],
            pivot_df[threat_col],
            color=plt.cm.RdYlGn_r(pivot_df[threat_col] / pivot_df[threat_col].max())
        )
        
        # Customize plot
        ax.set_xlabel('Threat Level')
        ax.set_title(title)
        ax.set_xlim(0, pivot_df[threat_col].max() * 1.1)
    
    plt.tight_layout()
    
    # Save figure if path provided
    if save_path:
        plt.savefig(save_path, dpi=300, bbox_inches='tight')
        logger.info(f"Saved environmental threat heatmap to {save_path}")
    
    return fig

def plot_correlation_matrix(
    correlation_matrix: pd.DataFrame,
    p_value_matrix: Optional[pd.DataFrame] = None,
    significance_level: float = 0.05,
    title: str = 'Correlation Matrix',
    save_path: Optional[str] = None
) -> plt.Figure:
    """
    Plot correlation matrix with optional significance markers.
    
    Args:
        correlation_matrix: DataFrame with correlation coefficients
        p_value_matrix: DataFrame with p-values (same shape as correlation_matrix)
        significance_level: Threshold for considering correlations significant
        title: Plot title
        save_path: Path to save the figure
        
    Returns:
        plt.Figure: The created figure
    """
    setup_plot_style()
    
    # Create mask for non-significant correlations
    if p_value_matrix is not None:
        mask = p_value_matrix > significance_level
    else:
        mask = np.zeros_like(correlation_matrix, dtype=bool)
    
    # Create plot
    fig, ax = plt.subplots(figsize=(12, 10))
    
    # Create heatmap
    cmap = sns.diverging_palette(230, 20, as_cmap=True)
    sns.heatmap(
        correlation_matrix,
        mask=mask,
        cmap=cmap,
        vmax=1.0,
        vmin=-1.0,
        center=0,
        square=True,
        linewidths=.5,
        cbar_kws={"shrink": .5},
        annot=True,
        fmt=".2f",
        ax=ax
    )
    
    # Customize plot
    ax.set_title(title)
    
    plt.tight_layout()
    
    # Save figure if path provided
    if save_path:
        plt.savefig(save_path, dpi=300, bbox_inches='tight')
        logger.info(f"Saved correlation matrix plot to {save_path}")
    
    return fig

def plot_time_series_with_events(
    time_series: pd.Series,
    events: pd.DataFrame,
    event_time_col: str = 'start_time',
    event_label_col: Optional[str] = None,
    window_days: int = 7,
    title: str = 'Time Series with Events',
    save_path: Optional[str] = None
) -> plt.Figure:
    """
    Plot time series data with event markers.
    
    Args:
        time_series: Time series data (Series with datetime index)
        events: DataFrame with event information
        event_time_col: Column in events with event timestamps
        event_label_col: Column in events with event labels (optional)
        window_days: Number of days to show around each event
        title: Plot title
        save_path: Path to save the figure
        
    Returns:
        plt.Figure: The created figure
    """
    setup_plot_style()
    
    # Sort events chronologically
    events = events.sort_values(event_time_col)
    
    # Number of events to show
    n_events = min(len(events), 4)  # Show up to 4 events
    
    # Create subplots for each event
    fig, axes = plt.subplots(n_events, 1, figsize=(14, 4 * n_events))
    if n_events == 1:
        axes = [axes]  # Make axes iterable if only one subplot
    
    # Plot each event
    for i, (_, event) in enumerate(events.head(n_events).iterrows()):
        if i >= len(axes):
            break
            
        # Get event time
        event_time = pd.to_datetime(event[event_time_col])
        
        # Create window around event
        start_time = event_time - pd.Timedelta(days=window_days)
        end_time = event_time + pd.Timedelta(days=window_days)
        
        # Filter time series for window
        window_data = time_series[
            (time_series.index >= start_time) &
            (time_series.index <= end_time)
        ]
        
        # Skip if no data in window
        if window_data.empty:
            continue
        
        # Plot time series
        window_data.plot(ax=axes[i])
        
        # Add event marker
        axes[i].axvline(
            event_time,
            color='red',
            linestyle='--',
            label='Event'
        )
        
        # Add event label if available
        if event_label_col and event_label_col in event:
            event_label = event[event_label_col]
            axes[i].text(
                event_time,
                axes[i].get_ylim()[1] * 0.9,
                f"{event_label}",
                rotation=90,
                verticalalignment='top'
            )
        
        # Format plot
        axes[i].set_title(f"Event at {event_time.strftime('%Y-%m-%d %H:%M')}")
        axes[i].set_xlabel('')
        axes[i].legend()
    
    # Set overall title
    fig.suptitle(title, fontsize=16)
    
    plt.tight_layout()
    plt.subplots_adjust(top=0.95)
    
    # Save figure if path provided
    if save_path:
        plt.savefig(save_path, dpi=300, bbox_inches='tight')
        logger.info(f"Saved time series plot to {save_path}")
    
    return fig

def plot_vulnerability_map(
    grid_components: pd.DataFrame,
    vulnerability_scores: pd.DataFrame,
    lat_col: str = 'latitude',
    lon_col: str = 'longitude',
    id_col: str = 'component_id',
    save_path: Optional[str] = None
) -> plt.Figure:
    """
    Plot vulnerability map with component locations.
    
    Args:
        grid_components: DataFrame with component information
        vulnerability_scores: DataFrame with vulnerability scores
        lat_col: Column with latitude
        lon_col: Column with longitude
        id_col: Column with component ID
        save_path: Path to save the figure
        
    Returns:
        plt.Figure: The created figure
    """
    setup_plot_style()
    
    # Check if location columns exist
    if lat_col not in grid_components.columns or lon_col not in grid_components.columns:
        logger.warning(f"Location columns {lat_col}/{lon_col} not found in grid_components")
        return None
    
    # Merge grid components with vulnerability scores
    if id_col in grid_components.columns and id_col in vulnerability_scores.columns:
        merged_df = pd.merge(
            grid_components,
            vulnerability_scores,
            on=id_col,
            how='inner'
        )
    else:
        logger.warning(f"Component ID column {id_col} not found in both DataFrames")
        return None
    
    # Create plot
    fig, ax = plt.subplots(figsize=(14, 10))
    
    # Plot scatter with vulnerability color
    scatter = ax.scatter(
        merged_df[lon_col],
        merged_df[lat_col],
        c=merged_df['vulnerability_score'],
        cmap='RdYlGn_r',
        s=100,
        alpha=0.7,
        edgecolors='k'
    )
    
    # Add component type if available
    if 'component_type' in merged_df.columns:
        # Create a different marker for each component type
        component_types = merged_df['component_type'].unique()
        markers = ['o', 's', '^', 'D', 'v', '<', '>', 'p', '*', 'h', 'H', '+', 'x', 'X', 'd', '|', '_']
        
        # Plot each component type with a different marker
        for i, comp_type in enumerate(component_types):
            type_data = merged_df[merged_df['component_type'] == comp_type]
            ax.scatter(
                type_data[lon_col],
                type_data[lat_col],
                c=type_data['vulnerability_score'],
                cmap='RdYlGn_r',
                s=100,
                alpha=0.7,
                edgecolors='k',
                marker=markers[i % len(markers)],
                label=comp_type
            )
        
        ax.legend(title='Component Type')
    
    # Add colorbar
    cbar = plt.colorbar(scatter, ax=ax)
    cbar.set_label('Vulnerability Score')
    
    # Customize plot
    ax.set_xlabel('Longitude')
    ax.set_ylabel('Latitude')
    ax.set_title('Grid Component Vulnerability Map')
    
    # Set aspect ratio to equal for geographic data
    ax.set_aspect('equal')
    
    plt.tight_layout()
    
    # Save figure if path provided
    if save_path:
        plt.savefig(save_path, dpi=300, bbox_inches='tight')
        logger.info(f"Saved vulnerability map to {save_path}")
    
    return fig

def plot_feature_importance(
    feature_importance: pd.Series,
    title: str = 'Feature Importance for Vulnerability Analysis',
    save_path: Optional[str] = None
) -> plt.Figure:
    """
    Plot feature importance from vulnerability model.
    
    Args:
        feature_importance: Series with feature importance values
        title: Plot title
        save_path: Path to save the figure
        
    Returns:
        plt.Figure: The created figure
    """
    setup_plot_style()
    
    # Sort features by importance
    sorted_features = feature_importance.sort_values(ascending=False)
    
    # Create plot
    fig, ax = plt.subplots(figsize=(12, 8))
    
    # Plot horizontal bar chart
    bars = ax.barh(
        sorted_features.index,
        sorted_features.values,
        color=plt.cm.viridis(np.linspace(0, 0.8, len(sorted_features)))
    )
    
    # Customize plot
    ax.set_xlabel('Importance')
    ax.set_title(title)
    
    plt.tight_layout()
    
    # Save figure if path provided
    if save_path:
        plt.savefig(save_path, dpi=300, bbox_inches='tight')
        logger.info(f"Saved feature importance plot to {save_path}")
    
    return fig
